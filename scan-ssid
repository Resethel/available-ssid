#!/bin/bash
#
# This script parses the output of the cli command "iw dev <adapter> scan"
# to determine all wi-fi networks that can be heard by an Ubuntu client. It
# uses grep to parse/scrape the command output.
#

#------------------------------------------------------------------------------#
# Constants and Global variables parsing Functions                             #
#------------------------------------------------------------------------------#

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_quiet="off"
_arg_pretty="off"

# set our path to 'iw' - enter "which iw" on the CLI if not sure usually "/sbin/iw" or "/usr/sbin/iw"
DEVICE_NAME=""
IW=$(which iw)

# List all of our Wi-Fi channels to lookup from the frequency we gather in the output of the "iw" scan command
declare -A CHANNELS=(
['2412']='1'
['2417']='2'
['2422']='3'
['2427']='4'
['2432']='5'
['2437']='6'
['2442']='7'
['2447']='8'
['2452']='9'
['2457']='10'
['2462']='11'
['2467']='12'
['2472']='13'
['5180']='36'
['5200']='40'
['5220']='44'
['5240']='48'
['5260']='52'
['5280']='56'
['5300']='60'
['5320']='64'
['5500']='100'
['5520']='104'
['5540']='108'
['5560']='112'
['5580']='116'
['5600']='120'
['5620']='124'
['5640']='128'
['5660']='132'
['5680']='136'
['5700']='140'
['5720']='144'
['5745']='149'
['5765']='153'
['5785']='157'
['5805']='161'
['5825']='165'
)

#------------------------------------------------------------------------------#
# Command parsing Functions                                                    #
#------------------------------------------------------------------------------#
# ARG_OPTIONAL_SINGLE([search],[s],[Search for a specific ssid information])
# ARG_OPTIONAL_BOOLEAN([pretty],[p],[Print headers before and after the printing])
# ARG_OPTIONAL_BOOLEAN([quiet],[q],[Make the execution quiet])
# ARG_POSITIONAL_SINGLE([wifi_interface],[Name of the wifi interface to scan],[])
# ARG_HELP([scan-ssid: a cli tool to scan all available Wi-Fi network])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.8.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate

function die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo -e "$1" >&2
	exit ${_ret}
}

function begins_with_short_option()
{
	local first_option all_short_options
	all_short_options='qph'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}


# Usage function
function print_help()
{
	printf '%s\n' "scan-ssid: a cli tool to scan available Wi-Fi network"
	printf 'Usage: %s [-q|--(no-)quiet] [-p|--(no-)pretty] [-h|--help] <device_name>\n\n' "$0"

	printf '%s\n' "Options:"
	printf '\t%s\t\t%s\n'		"<device_name>"	": Name of the wifi interface to scan"
	printf '\t%s\t\t%s\n'		"-h | --help"		": Show this help message"
	printf '\t%s\t\t%s\n'		"-p | --pretty"	": Print headers before and after the printing (ignored if '-s' is specified)"
	printf '\t%s\t\t%s\n'		"-q | --quiet"	": Make the execution quiet"
	printf '\t%s\t\t%s\n\n' "-s | --search"	": Search for a specific ssid information"
}

parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-s|--search)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_search="$2"
				shift
				;;
			--search=*)
				_arg_search="${_key##--search=}"
				;;
			-s*)
				_arg_search="${_key##-s}"
				;;
			-p|--no-pretty|--pretty)
				_arg_pretty="on"
				test "${1:0:5}" = "--no-" && _arg_pretty="off"
				;;
			-p*)
				_arg_pretty="on"
				_next="${_key##-p}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-p" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-q|--no-quiet|--quiet)
				_arg_quiet="on"
				test "${1:0:5}" = "--no-" && _arg_quiet="off"
				;;
			-q*)
				_arg_quiet="on"
				_next="${_key##-q}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-q" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'wifi_interface'"
	test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
	test "${_positionals_count}" -le 1 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_wifi_interface "

	shift $_shift_for
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

#------------------------------------------------------------------------------#
# Main Functions                                                               #
#------------------------------------------------------------------------------#

function quiet_echo()
{
	if [ "${_arg_quiet}" == "off" ]; then
		echo -e "$@"
	fi
}

function check_interface() # <device_name>
{
	# Checking that the interface is on
	ip link show dev "$1" | grep "UP"  >/dev/null 2>&1
	if [ $? -ne 0 ]; then
		# we reload the wifi and everything
		if [ "${_arg_quiet}" == "off" ]; then
			die "Interface $1 is down.\nTry running the command: \"sudo ip link set dev ${1} up\"" 1
		else
			exit 1
		fi
	fi
}

function scan_available_networks()  # <device_name>
{
	_DEVICE=$1
	# Set IFS to ensure grep output split only at line end on for statement
	local default_IFS=$IFS
	IFS='
	'
	# capture grep output in "iw" scan command in to array
	quiet_echo "Scanning networks available for ${_DEVICE} ..."
	IW_COMMAND=( `sudo $IW dev $_DEVICE scan | grep -o 'BSS ..\:..\:..:..\:..\:..\|SSID: .*\|signal\: .* \|freq\: .*'` )

	# Resetting IFS to previous value
	IFS=$default_IFS
}

function format_networks()
{
	local COUNT=1

	# Read through grep output from "iw" scan command
	for line in "${IW_COMMAND[@]}"
	do
	  # set IFS to space & tab
		local default_IFS=$IFS
	  IFS=" 	"

	  # first field should be BSS
	  if [[ $line =~ BSS ]]
	  then
	    bss_array=( $line )
	    bssid=${bss_array[1]}
	  fi

	  # second field should be freq:
	  if [[ $line =~ "freq:" ]]
	  then
	    freq_array=( $line )
	    freq=${freq_array[1]}
	  fi

	  # third field should be signal:
	  if [[ $line =~ "signal:" ]]
	  then
	    signal_array=( $line )
	    rssi=${signal_array[1]}
	  fi

	  # fourth field should be SSID
	  if [[ $line =~ "SSID" ]]
	  then
	    ssid_array=( $line )
	    # get rid of first array element so that we can print whole array, leaving just SSID name which may have spaces
	    unset ssid_array[0]
	    ssid=${ssid_array[@]}
	  fi

	  # Every 4th line we have all the input we need to write out the data
	  if [ $COUNT -eq 4 ]; then
	     channel=$(printf '%3s' "${CHANNELS[$freq]}")
	     echo "$bssid  $rssi  $channel    $freq    $ssid"

	    COUNT=0

	    # clear all arrays and variable for the next while loop run
	    ssid_array=()
	    signal_array=()
	    freq_array=()
	    bss_array=()
	    grep_output=()

	    bssid=''
	    ssid=''
	    freq=''
	    rssi=''
	    channel=''

	  fi

	  ((COUNT++))

	done | sort -k2

	# IFS=$default_IFS

	unset _DEVICE
}

#------------------------------------------------------------------------------#
# Main body                                                                    #
#------------------------------------------------------------------------------#

# Parsing the commands
parse_commandline "$@"
handle_passed_args_count
assign_positional_args
DEVICE_NAME=${_positionals[0]}

check_interface $DEVICE_NAME

# Scan network and check presence of IW_COMMAND
scan_available_networks $DEVICE_NAME
test ! -z "$IW_COMMAND" || die "${RED}${BOLD}Error${RESET}: 'iw' command couldn't be found" 127


if [ -z $_arg_search ]; then
	result=$(format_networks)
else
	result=$(format_networks | grep $_arg_search)
	if [  -z "${result}" ]; then
		die "$_arg_search is not available." 1
	fi
fi

# Echo the result
if [ "$_arg_pretty" == "on" ]; then
	echo "BSSID              RSSI     CH    Freq    SSID"
	echo "                   (dBm)          (Mhz)"
	echo "==============================================================="
else
	echo "BSSID              RSSI     CH    Freq    SSID"
fi

IFS=$default_IFS
echo $result

if [ "$_arg_pretty" == "on" ]; then
		echo "==============================================================="
		echo
fi


quiet_echo "Done."
exit 0
